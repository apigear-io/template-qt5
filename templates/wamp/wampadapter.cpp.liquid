{% comment %} // Copyright (c) ApiGear UG 2020 {% endcomment -%}
{{ module | licGPLcpp -}}
{% capture class%}Wamp{{interface.name}}Adapter{% endcapture %}


#include "{{class|lower}}.h"

#include <nlohmann/json.hpp>
#include "../api/agent.h"
#include "../api/json.adapter.h"

#include <QtCore>

using namespace ApiGear::WAMP;
using json = nlohmann::json;

{{class}}::{{class}}(Abstract{{interface}}* impl, QObject *parent)
    : QObject(parent)
    , m_impl(impl)
{    
    // setup state handling
    WampClient::instance()->doRegister("{{module}}.{{interface}}._get", [this](ProcedureArg arg) {
        this->handleGetState(arg);
    });
    WampClient::instance()->doRegister("{{module}}.{{interface}}._set", [this](ProcedureArg arg) {
        this->handleSetState(arg);
    });

    // setup operations
{% for operation in interface.operations %}
    WampClient::instance()->doRegister("{{module}}.{{interface}}.{{operation}}", [this](ProcedureArg arg) {
        this->handle{{operation.name|upperFirst}}(arg);
    });
{% endfor %}

    // setup properties
{% for property in interface.properties %}
    connect(impl, &Abstract{{interface}}::{{property}}Changed, this, &{{class}}::publishState);
{% endfor %}    

    // setup signals
{% for signal in interface.signals %}
    connect(impl, &Abstract{{interface}}::{{signal.name}}, this, &{{class}}::publish{{signal.name|upperFirst}});
{% endfor %}
}

{{class}}::~{{class}}()
{
}

json {{class}}::captureState()
{
    return json::object({
{% for property in interface.properties %}
        { "{{property}}", m_impl->{{property}}() }{% unless forloop.last %},{% endunless %}
{% endfor %}
    });
}

void {{class}}::applyState(const json& state)
{
{% for property in interface.properties %}
    if(state.contains("{{property}}")) {
        m_impl->set{{property.name|upperFirst}}(state["{{property}}"]);
    }    
{% endfor %}
}

void {{class}}::publishState()
{
    qDebug() << Q_FUNC_INFO;
    const json& fields = captureState();
    WampClient::instance()->doPublish("{{module}}.{{interface}}", json::array(), fields);
}

void {{class}}::handleGetState(ProcedureArg arg) 
{
    WampClient::instance()->doYield(arg.requestId, json::array(), this->captureState());
}

void {{class}}::handleSetState(ProcedureArg arg)
{
    this->applyState(arg.kwargs);
    WampClient::instance()->doYield(arg.requestId, json::array(), json::object());
}

{% for operation in interface.operations %}

void {{class}}::handle{{operation.name|upperFirst}}(ProcedureArg arg)
{    
    qDebug() << Q_FUNC_INFO;
{% for param in operation.params %}
    const {{param|qtReturn}}& {{param}} = arg.args.at({{ forloop.index0 }});        
{% endfor %}        
{% if operation.type == 'void' %}
    m_impl->{{operation}}({{ operation.params | map: 'name' | join: ', ' }});
    WampClient::instance()->doYield(arg.requestId, json::array(), json::object());
{% else %}
    const {{operation|qtReturn}}& result = m_impl->{{operation}}({{ operation.params | map: 'name' | join: ', ' }});
    const json& args = json::array({ result });
    WampClient::instance()->doYield(arg.requestId, args, json::object());
{% endif %}
}
{% endfor %}


{% for signal in interface.signals %}
void {{class}}::publish{{signal.name|upperFirst}}({{signal|qtParams}})
{
    qDebug() << Q_FUNC_INFO;
    json args = json::array({
{% for param in signal.params %}
      {{param}}{% unless forloop.last %},{% endunless %}
{% endfor %}
    });
    WampClient::instance()->doPublish("{{module}}.{{interface}}.{{operation}}", args, json::object());
}
{% endfor %}



